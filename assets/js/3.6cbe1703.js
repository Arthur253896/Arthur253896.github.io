(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{273:function(t,a,s){t.exports=s.p+"assets/img/hashex.17c194ce.png"},274:function(t,a,s){t.exports=s.p+"assets/img/hashfun.36030200.png"},275:function(t,a,s){t.exports=s.p+"assets/img/lalian.7100d26c.png"},276:function(t,a,s){t.exports=s.p+"assets/img/xianxing.6dbf9d03.png"},277:function(t,a,s){t.exports=s.p+"assets/img/set.97bb4185.png"},278:function(t,a,s){t.exports=s.p+"assets/img/hashmap.62c73ddc.png"},305:function(t,a,s){"use strict";s.r(a);var e=s(14),v=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"什么是哈希表-hashtable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是哈希表-hashtable"}},[t._v("#")]),t._v(" 什么是哈希表(HashTable)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("哈希表是根据关键码的值而直接进行访问的数据结构\n")])])]),a("p",[t._v("数组就是一张哈希表:\n"),a("img",{attrs:{src:s(273),alt:""}})]),t._v(" "),a("h2",{attrs:{id:"hash-table要解决什么问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-table要解决什么问题"}},[t._v("#")]),t._v(" hash table要解决什么问题？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("一般哈希表都是用来快速判断一个元素是否出现集合里。\n")])])]),a("p",[t._v("例如要查询一个名字是否在这所学校里。")]),t._v(" "),a("p",[t._v("要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。")]),t._v(" "),a("p",[t._v("我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。")]),t._v(" "),a("p",[t._v("将学生姓名映射到哈希表上就涉及到了hash function ，也就是哈希函数。")]),t._v(" "),a("h2",{attrs:{id:"什么是-哈希函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-哈希函数"}},[t._v("#")]),t._v(" 什么是 哈希函数？")]),t._v(" "),a("p",[a("img",{attrs:{src:s(274),alt:""}})]),t._v(" "),a("p",[t._v("将学生姓名映射到哈希表的索引上，通过hashcode把名字转换为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。")]),t._v(" "),a("p",[t._v("如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？")]),t._v(" "),a("p",[t._v("此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。")]),t._v(" "),a("p",[t._v("此时问题又来了，哈希表我们刚刚说过，就是一个数组。")]),t._v(" "),a("p",[t._v("如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。")]),t._v(" "),a("p",[t._v("接下来哈希碰撞登场")]),t._v(" "),a("h2",{attrs:{id:"哈希碰撞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哈希碰撞"}},[t._v("#")]),t._v(" 哈希碰撞")]),t._v(" "),a("p",[t._v("不同的学生映射到同一个位置就叫哈希碰撞，这时候有两种解决方法：拉链法和线性探针法；")]),t._v(" "),a("h3",{attrs:{id:"拉链法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拉链法"}},[t._v("#")]),t._v(" 拉链法")]),t._v(" "),a("p",[a("img",{attrs:{src:s(275),alt:""}}),t._v("\n（数据大小是dataize，哈希表大小是tablesize）\n将映射到同一索引的元素通过链表连接表示出来；")]),t._v(" "),a("p",[t._v("其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间")]),t._v(" "),a("h3",{attrs:{id:"线性探针法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线性探针法"}},[t._v("#")]),t._v(" 线性探针法")]),t._v(" "),a("p",[t._v("条件是：tablesize>datasize，在发生冲突时，在哈希表中找到最相近的空位存放冲突元素。\n"),a("img",{attrs:{src:s(276),alt:""}})]),t._v(" "),a("h2",{attrs:{id:"常用的三种hash结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用的三种hash结构"}},[t._v("#")]),t._v(" 常用的三种hash结构")]),t._v(" "),a("p",[t._v("1、数组")]),t._v(" "),a("p",[t._v("2、set（集合）")]),t._v(" "),a("p",[t._v("3、map（映射）")]),t._v(" "),a("p",[t._v("在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:s(277),alt:""}}),t._v("\nstd::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。")]),t._v(" "),a("p",[a("img",{attrs:{src:s(278),alt:""}})]),t._v(" "),a("p",[t._v("std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。")]),t._v(" "),a("p",[t._v("当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。")]),t._v(" "),a("p",[t._v("那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。")]),t._v(" "),a("p",[t._v("其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。")]),t._v(" "),a("p",[t._v("虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。")])])}),[],!1,null,null,null);a.default=v.exports}}]);